TUGAS 7
1. Widget tree pada Flutter adalah struktur hierarki yang menggambarkan bagaimana semua elemen antarmuka pengguna tersusun dari widget-widget kecil hingga membentuk tampilan utuh aplikasi. Setiap komponen di layar, seperti teks, tombol, gambar, atau bahkan keseluruhan halaman, merupakan bagian dari pohon widget ini. Flutter membangun dan memperbarui tampilan dengan cara menelusuri dan merender widget tree tersebut dari akar (root) hingga ke elemen paling bawah (leaf).
Hubungan parent-child (induk-anak) dalam widget tree menunjukkan bagaimana satu widget dapat membungkus atau menampung widget lain di dalamnya. Widget parent bertanggung jawab mengatur tata letak, posisi, dan perilaku dari widget child-nya, sementara widget child menampilkan konten atau elemen spesifik di dalam struktur tersebut.

2. Saya memakai widget-widget Flutter seperti Scaffold (kerangka halaman dan tempat AppBar + body), AppBar (header dengan Text sebagai judul), Text (menampilkan teks), Padding dan SizedBox (mengatur jarak), Column dan Row (layout vertikal/horizontal), Center (memusatkan anak), GridView.count (menata ItemCard dalam grid), Card dan Container sebagai wadah dengan styling, padding, dan ukuran serta memanfaatkan MediaQuery untuk menyesuaikan lebar dan Icon untuk ikon pada tombol.
Selain itu saya menggunakan Material + InkWell untuk area yang bisa diketuk beserta efek ripple, ScaffoldMessenger + SnackBar untuk menampilkan pesan saat tombol ditekan, dan juga membuat dua widget kustom, yaitu InfoCard yang menampilkan kartu informasi NPM/Name/Class menggunakan Card, Container, Column dan ItemCard yang merepresentasikan tombol produk—menggabungkan Material, InkWell, Icon, dan Text—dengan warna dari model ItemHomepage, yang sendiri hanya model data berisi name, icon, dan color

3. Widget MaterialApp berfungsi sebagai pembungkus utama aplikasi Flutter. Widget ini menyediakan konfigurasi dasar seperti tema warna, judul aplikasi, pengaturan navigasi antarhalaman, serta integrasi dengan fitur penting seperti Scaffold, AppBar, dan SnackBar. MaterialApp sering digunakan sebagai widget root karena ia menjadi titik awal yang menyiapkan konteks Material untuk seluruh widget di bawahnya sehingga semua elemen UI dapat mengikuti standar tampilan, interaksi, dan perilaku khas aplikasi berbasis Material Design.

4. StatelessWidget adalah widget yang tidak menyimpan state internal, bersifat immutable dan hanya menggambar ulang jika properti yang diberikan oleh parent berubah sehingga cocok untuk UI yang bersifat statis seperti teks, ikon, atau layout sederhana. Sebaliknya StatefulWidget punya objek State yang menyimpan data mutable dan lifecycle (mis. initState, setState, dispose) sehingga dipakai bila UI harus berubah seiring waktu, seperti respon input pengguna (form, toggle), data dari jaringan, animasi, atau komponen yang perlu update internal. Pilih StatelessWidget bila bisa untuk kesederhanaan dan kinerja, dan gunakan StatefulWidget hanya ketika ada kebutuhan perubahan state.

5. BuildContext adalah objek yang merepresentasikan lokasi atau posisi suatu widget di dalam widget tree Flutter. Objek ini penting karena memberi akses ke informasi konteks lingkungan widget, seperti tema, ukuran layar, navigator, atau parent widget yang menaunginya. Dalam metode build, BuildContext digunakan untuk membangun tampilan widget sesuai hierarki yang ada, serta memudahkan widget berinteraksi dengan elemen lain di atasnya dalam tree, misalnya saat memanggil Theme.of(context) untuk mengambil warna tema atau ScaffoldMessenger.of(context) untuk menampilkan SnackBar.

6. Konsep hot reload di Flutter memungkinkan developer melihat hasil perubahan kode secara instan tanpa kehilangan state aplikasi yang sedang berjalan. Saat hot reload dijalankan, Flutter hanya memuat ulang bagian kode yang berubah dan memperbarui widget tree secara dinamis sehingga sangat efisien untuk mempercepat proses pengembangan UI. Sebaliknya, hot restart memulai ulang seluruh aplikasi dari awal, seluruh state akan direset dan widget tree dibangun ulang sepenuhnya, mirip seperti menjalankan ulang aplikasi dari nol. Hot reload cocok untuk mengubah tampilan atau logika kecil, sedangkan hot restart digunakan bila ada perubahan besar seperti inisialisasi variabel global atau struktur utama aplikasi.


TUGAS 8
1. Navigator.push() digunakan untuk menambahkan halaman baru ke dalam tumpukan (stack) navigasi tanpa menghapus halaman sebelumnya. Artinya, user masih bisa kembali ke halaman sebelumnya menggunakan tombol “Back”. Misalnya, ketika user berada di halaman utama dan ingin membuka form tambah produk, kita bisa menggunakan Navigator.push() agar setelah selesai mengisi form, pengguna dapat kembali ke halaman utama dengan mudah.
Sementara itu, Navigator.pushReplacement() akan menggantikan halaman saat ini dengan halaman baru sehingga halaman sebelumnya dihapus dari tumpukan dan tidak bisa dikembalikan dengan tombol “Back”. Dalam aplikasi Football Shop, metode ini cocok digunakan setelah pengguna menyelesaikan suatu proses yang tidak perlu dikunjungi lagi, misalnya setelah berhasil login atau menyimpan produk baru, lalu diarahkan langsung ke halaman daftar produk tanpa bisa kembali ke form.

2. Saya memanfaatkan hierarchy widget seperti Scaffold, AppBar, dan Drawer untuk menjaga struktur halaman yang konsisten di seluruh aplikasi. Scaffold digunakan sebagai kerangka utama setiap halaman agar elemen-elemen seperti AppBar, Drawer, dan body memiliki posisi dan fungsi yang sama di seluruh tampilan. AppBar digunakan untuk menampilkan judul halaman serta memberikan navigasi atau identitas halaman yang jelas bagi user. Sementara itu, Drawer dimanfaatkan sebagai menu navigasi samping yang memungkinkan user berpindah antarhalaman dengan mudah tanpa kehilangan konteks. Dengan kombinasi ini, setiap halaman di aplikasi memiliki tata letak yang seragam, mudah dipahami, dan memberikan pengalaman pengguna yang konsisten.

3. Dalam desain antarmuka, penggunaan widget seperti Padding, SingleChildScrollView, dan ListView memberikan fleksibilitas serta kenyamanan visual bagi user. Padding digunakan untuk memberikan jarak antar elemen agar tampilan form tidak terlihat padat dan lebih mudah dibaca. SingleChildScrollView memungkinkan seluruh isi form dapat di-scroll ketika konten melebihi tinggi layar sehingga user tetap bisa mengakses semua input tanpa terpotong. Sedangkan ListView berguna untuk menampilkan elemen form dalam urutan vertikal yang panjang dan dinamis. Contohnya adalah saya menggunakan Padding untuk memberi jarak antar field input seperti nama produk, harga, dan deskripsi; serta SingleChildScrollView agar form dapat digulir ke bawah saat semua elemen ditampilkan.

4. Saya menyesuaikan warna tema aplikasi dengan memilih warna utama merah yang mencerminkan semangat, energi, dan keberanian. Warna merah ini diterapkan secara konsisten pada elemen penting seperti AppBar, tombol utama, serta ikon navigasi untuk memperkuat identitas visual aplikasi. Selain itu, saya menggunakan skema warna sekunder merah tua (redAccent) untuk memberikan variasi tanpa menghilangkan kesatuan desain. Dengan pengaturan warna melalui ThemeData pada MaterialApp, seluruh halaman memiliki tampilan yang seragam dan profesional sehingga user dapat langsung mengenali gaya khas ArabgokStore saat menggunakan aplikasi.


TUGAS 9
1. Kita perlu membuat model Dart saat mengambil atau mengirim data JSON karena model memberikan struktur yang jelas dan aman terhadap tipe data. Dengan model, setiap field memiliki tipe yang pasti (contohnya String, int, atau bool) sehingga IDE dapat melakukan pengecekan tipe dan membantu mencegah error saat proses parsing atau penggunaan data. Model juga memudahkan konversi dari dan ke JSON melalui fromJson() dan toJson() sehingga proses pengolahan data menjadi lebih konsisten dan terstandarisasi.
Jika kita langsung menggunakan Map<String, dynamic> tanpa model, maka kita kehilangan perlindungan tipe dan null-safety, seperti field yang salah nama, nilai yang null, atau tipe yang tidak sesuai baru akan terdeteksi saat runtime dan menyebabkan crash yang sulit dilacak. Selain itu, kode menjadi jauh lebih sulit dirawat dan diperluas karena tidak ada struktur yang mendokumentasikan bentuk data sebenarnya. Pendekatan tanpa model membuat kode berantakan dan penuh potensi bug, sementara model memberikan maintainability, keterbacaan, dan keamanan tipe yang jauh lebih baik.

2. Package http berfungsi sebagai alat dasar untuk melakukan request HTTP biasa, seperti GET atau POST, tanpa mekanisme manajemen sesi. Artinya setiap request dianggap berdiri sendiri sehingga jika backend membutuhkan autentikasi atau login berbasis cookie, package http tidak otomatis mengirim atau menyimpan cookie tersebut. Kamu harus mengelola header, cookie, dan autentikasi secara manual.
Sementara itu, CookieRequest (dari package pbp_django_auth) dirancang khusus untuk berkomunikasi dengan backend Django yang menggunakan session-based authentication. CookieRequest secara otomatis menyimpan cookie login, mengirimkannya kembali pada setiap request berikutnya, serta menyediakan fungsi login, logout, dan request POST/GET yang sudah terautentikasi. Dengan demikian, http cocok untuk request umum tanpa autentikasi, sedangkan CookieRequest sangat penting untuk tugas ini karena memungkinkan Flutter tetap “logged in” dan mengakses endpoint Django yang membutuhkan user session.

3. Instance CookieRequest perlu dibagikan ke semua komponen aplikasi Flutter karena objek inilah yang menyimpan seluruh informasi sesi user, termasuk status login dan cookie autentikasi dari Django. Jika setiap halaman atau widget membuat instance CookieRequest sendiri, maka cookie tidak akan terbagi sehingga halaman lain tidak akan mengenali bahwa user sudah login dan request ke backend yang membutuhkan autentikasi akan gagal. Dengan membagikan satu instance CookieRequest secara global melalui provider, seluruh bagian aplikasi dapat berbagi status login yang konsisten, mengakses endpoint terproteksi, serta menjaga pengalaman user tetap mulus tanpa perlu login berulang-ulang.

4. Agar Flutter dapat berkomunikasi dengan Django, backend dan frontend harus “saling mengizinkan” secara jaringan dan keamanan. Penambahan 10.0.2.2 pada ALLOWED_HOSTS diperlukan karena di Android emulator, localhost komputer kita direferensikan sebagai 10.0.2.2 sehingga Django hanya mau merespons request dari alamat itu jika sudah terdaftar. CORS perlu diaktifkan supaya Django mengizinkan request dari aplikasi lain (termasuk Flutter) dan tidak memblokirnya sebagai cross-origin yang berbahaya. Pengaturan SameSite/cookie penting agar cookie sesi bisa tetap terkirim pada request dari Flutter sehingga autentikasi berbasis session bekerja. Di sisi Android, izin akses internet <uses-permission android:name="android.permission.INTERNET" /> wajib ada di AndroidManifest.xml, kalau tidak, aplikasi tidak bisa melakukan HTTP request sama sekali. Jika konfigurasi-konfigurasi ini salah atau tidak lengkap, efeknya bisa berupa request gagal, respons diblokir CORS, cookie sesi tidak terkirim (jadi selalu dianggap belum login), dan pada akhirnya Flutter tidak dapat berkomunikasi dengan Django dengan benar.

5. Mekanisme pengiriman data dari input sampai akhirnya tampil di Flutter berlangsung melalui beberapa tahap yang saling terhubung. Ketika user memasukkan data melalui form di Flutter, data tersebut dikumpulkan lalu dikirim ke backend Django melalui request HTTP (POST) menggunakan CookieRequest sehingga cookie sesi tetap disertakan. Django menerima data tersebut, memvalidasi, lalu menyimpannya ke database melalui model yang sudah dibuat. Setelah berhasil disimpan, Flutter kemudian melakukan request GET ke endpoint JSON Django untuk mengambil data terbaru. Django merespons dengan mengirim JSON yang berisi daftar objek yang telah disimpan di database. JSON ini lalu diparsing oleh Flutter ke dalam model Dart (misalnya ProductEntry) sehingga setiap field memiliki tipe data yang jelas. Terakhir, data model tersebut ditampilkan di UI melalui widget seperti ListView atau Card sehingga user dapat melihat data yang mereka masukkan sebelumnya.

6. Mekanisme autentikasi dimulai ketika user melakukan register di Flutter, yaitu data akun (username dan password) dikirim ke endpoint Django yang menangani login, lalu Django memvalidasi dan membuat user baru di database. Setelah akun ada, saat login, Flutter mengirimkan username dan password ke endpoint login Django menggunakan CookieRequest. Jika kredensial valid, Django membuat session untuk user tersebut dan mengirim kembali cookie sesi lewat respons, yang kemudian disimpan otomatis oleh CookieRequest. Cookie ini akan disertakan pada setiap request berikutnya sehingga Django bisa mengenali user sebagai “sudah login” dan mengizinkan akses ke endpoint yang diproteksi (misalnya endpoint JSON produk milik user). Setelah login sukses, Flutter biasanya meng-update state (misalnya berpindah dari halaman login ke halaman menu/home) dan menampilkan konten yang hanya bisa diakses user terautentikasi. Saat logout, Flutter memanggil endpoint logout Django. Django menghapus session di server dan mengembalikan respons, sementara CookieRequest menghapus cookie lokal sehingga request berikutnya tidak lagi dianggap login dan Flutter bisa mengarahkan user kembali ke halaman login.

7. Pertama saya pastikan dulu proyek Django-nya sehat dan bisa diakses.saya cek settings.py: nambah 10.0.2.2 ke ALLOWED_HOSTS, aktifin django-cors-headers, set CORS_ALLOW_ALL_ORIGINS, CORS_ALLOW_CREDENTIALS, dan atur SESSION_COOKIE_SAMESITE / CSRF_COOKIE_SAMESITE ke 'None' sesuai kebutuhan integrasi Flutter.
Di sisi Django,saya pastikan flow login–register sudah jalan dulu untuk web. Lalu saya tambahin endpoint khusus yang bisa dikonsumsi Flutter (format JSON), misalnya untuk login dan register, dengan mengembalikan JsonResponse berisi informasi user. Fungsi-fungsi ini saya lengkapi dengan authenticate dan login supaya kalau kredensial benar, Django bikin session dan ngasih cookie ke client. Nantinya cookie ini yang akan dipegang CookieRequest di Flutter.
Di Flutter,saya bikin dua halaman baru, yaitu LoginPage dan RegisterPage. Masing-masing pakai TextEditingController buat ambil input username dan password dari user. Untuk register,saya kirim body JSON (username dan password) ke endpoint /auth/register/ Django pakai request.postJson, terus kalau statusnya sukses saya balikkan user ke halaman login. Untuk login, saya pakai request.login("http://localhost:8000/auth/login/". Kalau request.loggedIn == true, berarti Django sudah ngasih cookie session dan CookieRequest otomatis nyimpan. Setelah itu saya Navigator.pushReplacement ke MyHomePage dan tampilin snackbar “Login berhasil”.
Supaya semua halaman bisa pakai sesi login yang sama, saya ubah main.dart dan bungkus MaterialApp pakai Provider yang nge-provide satu instance CookieRequest. Di setiap screen yang butuh komunikasi ke backend. Dengan cara ini, halaman menu, list produk, form Flutter, semuanya pakai session yang sama tanpa harus login ulang.
Setelah backend siap, saya buka endpoint /json/ Django, ambil contoh JSON-nya, lalu generate model Dart pakai Quicktype dan saya sesuaikan lagi. Jadinya class ProductEntry dengan field seperti id, name, description, category, thumbnail, productViews, price, stock, rating, brand, createdAt, isFeatured, dan userId. Di dalamnya ada factory ProductEntry.fromJson dan toJson() supaya konversi JSON ke objek rapi dan aman secara tipe. Model ini yang kupakai di semua halaman Flutter saat parsing respons Django.
Lalu, saya bikin screen ProductEntryListPage. Di situ saya tulis fungsi fetchProduct(CookieRequest request) yang manggil request.get('http://localhost:8000/json/') lalu looping responsnya dan tiap elemen ku-convert jadi ProductEntry. Di build, saya pakai FutureBuilder dan kalau datanya sudah ada, saya tampilkan pakai ListView.builder dengan ProductEntryCard. Di dalam card itu saya nampilin field yang diminta, yaitu name, price, description, thumbnail (lewat endpoint proxy-image), category, dan badge Featured.
Lalu, saya bikin ProductDetailPage yang menerima satu argumen ProductEntry product. Dari ProductEntryListPage, waktu user klik card, saya pakai Navigator.push ke ProductDetailPage. Di halaman detail ini saya tampilkan semua atribut model, seperti id, name, description lengkap, category, thumbnail, price, stock, rating, brand, views, tanggal, dll. Di bagian bawah saya tambahin satu ElevatedButton “Back to List” yang isinya Navigator.pop supaya memenuhi requirement.
Karena tugasnya juga minta filter produk berdasarkan user login, saya tambah view baru show_json_my_products di main/views.py. Isinya Product.objects.filter(user=request.user) lalu dikonversi ke list dictionary dengan struktur sama seperti /json/ (ada id, name, description, category, thumbnail, product_views, price, stock, rating, brand, created_at, is_featured, user_id). View ini saya kasi decorator @login_required dan didaftarkan di urls.py sebagai path json/my-products/, posisinya saya taruh sebelum route json/<str:product_id>/ supaya nggak ketangkep sebagai param id.